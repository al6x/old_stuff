{ "_id" : { "$oid" : "4e7b89807a9d4e2cdd000002" }, "tags" : [ "Complexity", "DI", "IoC", "Project", "_class:Models::Note" ], "slug" : "you-underestimate-the-power-of-ioc", "attachments" : [ { "file" : "dark side.jpg", "_class" : "Models::Attachment" } ], "name" : "You underestimate the power of IoC", "text" : "<p><a href=\"/fs/4e7b89807a9d4e2cdd000002/dark%20side.jpg\"><img src=\"/fs/4e7b89807a9d4e2cdd000002/dark%20side.thumb.jpg\" alt=\"\" /></a> There are rumors in Ruby community about <strong>IoC</strong>. Mainly about how someone tried it, failed and now trying to convince everyone else that IoC is bad, it’s “not a Ruby way” and the “Ruby itself has an IoC capabilities”.</p>\n\n<p>I use IoC as a heart of Rad Web Framwork (this site powered with it), and it tremendously simplify my work.</p>\n\n<p>One of the biggest advantage of IoC in Java comes from its AOP technics (kind of Metaprogramming) – and because Ruby already have all this stuff – it’s easy to be mislead to thinking that there’s no need for IoC. </p>\n\n<p>But this is wrong, there are other, no less important advantages of IoC:</p>\n\n<ul><li><p><strong>Automatic Dependency Resolving</strong>: automatic – means that <strong>there should be no any ‘require’ at all</strong>, all Your Classes and Components should be automatically located, loaded, initialized and wired together.<br />\nIf You explicitly use ‘require’ and initialization to manage pieces of Your App with IoC – You are using it wrong!</p></li>\n<li><p><strong>Configuration Management</strong>: there should be no explicit ‘config’ usage in Your code, all variables from config files should be injected automatically into right places of Your App. <br />\nIf You explicitly use :config with IoC – You are using it wrong (well, sometime You has to use it, but most of time it works automatically and stays invisible)!</p></li>\n<li><p>Static and <strong>Dynamic</strong> Component Life-Cycle Management – for some strange reason all of Ruby IoC I’ve seen worked only with Static Components (Singletons). It assembles static structure of App and completelly ignores dynamic objects (like creating new Controller per request).<br />\nThat’s wrong, IoC should manage Dynamic Components as well.</p></li>\n<li><p>99% of time <strong>IoC is silent and invisible</strong>, if You are forced to learn IoC API or see it in Your code – You are using it wrong!</p></li>\n</ul><p>And using IoC without this stuff is like to trying to saw with the chainsaw turned off.</p>\n\n<p>It’s hard to show a small code example that will ultimately proove the advantages of IoC, because it shines most when Your app gets big. Then it will pay for itself by allowing You to have simple and clean code instead of monolyth or dependency hell.</p>\n\n<h2>Sample</h2>\n\n<p>Below are small sample of <a href=\"https://github.com/alexeypetrushin/micon\">Micon</a> IoC (this example doesn’t show dependency management, it’s too simpe). More of real-life code snippets will be in later articles.</p>\n\n<pre><code class=\"ruby\">require ‘micon’\n\n# Here’s our Web Framework, let’s call it Rad\n\n# Let’s define shortcut to access the IoC API (optional\n# but handy step). I don’t know how You would like to call it,  \n# so I leave this step to You.\ndef rad; MICON end\n\n# let’s define some components  \n# the :logger is one per application, it’s a static component (like singleton)\nclass Logger\n  register_as :logger\n  attr_accessor :log_file_path\n  def info msg\n    puts “#{msg} (writen to #{log_file_path})” unless defined?(RSpec)\n  end\nend\n\n# To demostrate basics of working with compnents let’s configure our :logger\n# explicitly (in the next example, it will be configured automatically).\nrad.logger.log_file_path = ‘/tmp/rad.log’  \n\n# The :router requires complex initialization, so we use \n# another form of component registration.\nclass Router\n  def initialize routes; @routes = routes end\n  def decode request;  \n    class_name, method = @routes[request.url]  \n    return eval(class_name), method # returning actual class\n  end\nend\nrad.register :router do\n  Router.new ‘/index’ =&gt; [‘PagesController’, :index]\nend\n\n# The :controller component should be created and destroyed dynamically,  \n# for each request, we specifying that component is dynamic  \n# by declaring it’s :scope.  \n# And, we don’t know beforehead what it actully will be, for different  \n# request there can be different controllers,  \n# so, here we just declaring it without any initialization block, it\n# will be created at runtime later.\nrad.register :controller, scope: :request\n\n# Let’s define some of our controllers, the PagesController, note – we\n# don’t register it as component.\nclass PagesController\n  # We need access to :logger and :request, let’s inject them\n  inject logger: :logger, request: :request\n\n  def index\n    # Here we can use injected component\n    logger.info “Application: processing #{request}”  \n  end\nend\n\n# Request is also dynamic, and it also can’t be created beforehead.\n# We also registering it without initialization, it will be\n# created at runtime later.\nclass Request\n  attr_reader :url  \n  def initialize url; @url = url end  \n  def to_s; @url end\nend\n# Registering without initialization block.\nrad.register :request, scope: :request\n\n# We need to integrate our application with web server, for example with the Rack.\n# When the server receive web request, it calls the :call method of our RackAdapter\nclass RackAdapter\n  # Injecting components\n  inject request: :request, controller: :controller\n\n  def call env\n    # We need to tell Micon that the :request scope is started, so it will know\n    # that some dynamic components should be created during this scope and  \n    # destroyed at the end of it.\n    rad.activate :request, {} do\n      # Here we manually creating the Request component\n      self.request = Request.new ‘/index’\n\n      # The :router also can be injected via :inject,\n      # but we can also use another way to access components,\n      # every component also availiable as rad.\n      controller_class, method = rad.router.decode request\n\n      # Let’s create and call our controller\n      self.controller = controller_class.new\n      controller.send method\n    end\n  end\nend  \n\n# Let’s pretend that there’s a Web Server and run our application,\n# You should see something like this in the console:\n#   Application: processing /index\nRackAdapter.new.call({})\n</code></pre>", "original_text" : "!![icon] There are rumors in Ruby community about **IoC**. Mainly about how someone tried it, failed and now trying to convince everyone else that IoC is bad, it's \"not a Ruby way\" and the \"Ruby itself has an IoC capabilities\".\n\nI use IoC as a heart of Rad Web Framwork (this site powered with it), and it tremendously simplify my work.\n\nOne of the biggest advantage of IoC in Java comes from its AOP technics (kind of Metaprogramming) - and because Ruby already have all this stuff - it's easy to be mislead to thinking that there's no need for IoC. \n\nBut this is wrong, there are other, no less important advantages of IoC:\n\n- **Automatic Dependency Resolving**: automatic - means that **there should be no any 'require' at all**, all Your Classes and Components should be automatically located, loaded, initialized and wired together.\nIf You explicitly use 'require' and initialization to manage pieces of Your App with IoC - You are using it wrong!\n\n- **Configuration Management**: there should be no explicit 'config' usage in Your code, all variables from config files should be injected automatically into right places of Your App. \nIf You explicitly use :config with IoC - You are using it wrong (well, sometime You has to use it, but most of time it works automatically and stays invisible)!\n\n- Static and **Dynamic** Component Life-Cycle Management - for some strange reason all of Ruby IoC I've seen worked only with Static Components (Singletons). It assembles static structure of App and completelly ignores dynamic objects (like creating new Controller per request).\nThat's wrong, IoC should manage Dynamic Components as well.\n\n- 99% of time **IoC is silent and invisible**, if You are forced to learn IoC API or see it in Your code - You are using it wrong!\n\nAnd using IoC without this stuff is like to trying to saw with the chainsaw turned off.\n\nIt's hard to show a small code example that will ultimately proove the advantages of IoC, because it shines most when Your app gets big. Then it will pay for itself by allowing You to have simple and clean code instead of monolyth or dependency hell.\n\n## Sample\n\nBelow are small sample of [Micon][micon] IoC (this example doesn't show dependency management, it's too simpe). More of real-life code snippets will be in later articles.\n\n``` ruby\nrequire 'micon'\n\n# Here's our Web Framework, let's call it Rad\n\n# Let's define shortcut to access the IoC API (optional\n# but handy step). I don't know how You would like to call it,  \n# so I leave this step to You.\ndef rad; MICON end\n\n# let's define some components  \n# the :logger is one per application, it's a static component (like singleton)\nclass Logger\n  register_as :logger\n  attr_accessor :log_file_path\n  def info msg\n    puts \"#{msg} (writen to #{log_file_path})\" unless defined?(RSpec)\n  end\nend\n\n# To demostrate basics of working with compnents let's configure our :logger\n# explicitly (in the next example, it will be configured automatically).\nrad.logger.log_file_path = '/tmp/rad.log'  \n\n# The :router requires complex initialization, so we use \n# another form of component registration.\nclass Router\n  def initialize routes; @routes = routes end\n  def decode request;  \n    class_name, method = @routes[request.url]  \n    return eval(class_name), method # returning actual class\n  end\nend\nrad.register :router do\n  Router.new '/index' => ['PagesController', :index]\nend\n\n# The :controller component should be created and destroyed dynamically,  \n# for each request, we specifying that component is dynamic  \n# by declaring it's :scope.  \n# And, we don't know beforehead what it actully will be, for different  \n# request there can be different controllers,  \n# so, here we just declaring it without any initialization block, it\n# will be created at runtime later.\nrad.register :controller, scope: :request\n\n# Let's define some of our controllers, the PagesController, note - we\n# don't register it as component.\nclass PagesController\n  # We need access to :logger and :request, let's inject them\n  inject logger: :logger, request: :request\n\n  def index\n    # Here we can use injected component\n    logger.info \"Application: processing #{request}\"  \n  end\nend\n\n# Request is also dynamic, and it also can't be created beforehead.\n# We also registering it without initialization, it will be\n# created at runtime later.\nclass Request\n  attr_reader :url  \n  def initialize url; @url = url end  \n  def to_s; @url end\nend\n# Registering without initialization block.\nrad.register :request, scope: :request\n\n# We need to integrate our application with web server, for example with the Rack.\n# When the server receive web request, it calls the :call method of our RackAdapter\nclass RackAdapter\n  # Injecting components\n  inject request: :request, controller: :controller\n  \n  def call env\n    # We need to tell Micon that the :request scope is started, so it will know\n    # that some dynamic components should be created during this scope and  \n    # destroyed at the end of it.\n    rad.activate :request, {} do\n      # Here we manually creating the Request component\n      self.request = Request.new '/index'\n  \n      # The :router also can be injected via :inject,\n      # but we can also use another way to access components,\n      # every component also availiable as rad.<component_name>\n      controller_class, method = rad.router.decode request\n  \n      # Let's create and call our controller\n      self.controller = controller_class.new\n      controller.send method\n    end\n  end\nend  \n\n# Let's pretend that there's a Web Server and run our application,\n# You should see something like this in the console:\n#   Application: processing /index\nRackAdapter.new.call({})\n```\n\n[micon]: https://github.com/alexeypetrushin/micon\n[icon]: /fs/4e7b89807a9d4e2cdd000002/dark%20side.thumb.jpg", "owner_name" : "admin", "viewers" : [ "manager", "member", "user", "user:admin" ], "collaborators" : [], "updated_at" : { "$date" : 1316726055254 }, "teaser" : " There are rumors in Ruby community about IoC. Mainly about how someone tried it, failed and now trying to convince everyone else that IoC is bad, it’s “not a Ruby way” and the “Ruby itself has an IoC capabilities”. I use IoC as a heart of Rad Web Framwork (this site powered with it), and it tremendously simplify my work. One of the biggest ...", "created_at" : { "$date" : 1316718976563 }, "comments_count" : 0, "_class" : "Models::Note" }
{ "_id" : { "$oid" : "4e7b9f9b7a9d4e31fc000001" }, "tags" : [ "Administration", "Project", "S3", "SSH", "_class:Models::Note" ], "slug" : "virtual-file-system", "attachments" : [], "name" : "Virtual File System (Local, S3, SFTP)", "text" : "<p><a href=\"http://alexeypetrushin.github.com/vfs\">Virtual File System</a> provides clean, simple and unified API over different storages (Local File System, AWS S3, SFTP).</p>\n\n<p>I/O operations:</p>\n\n<pre><code class=\"ruby\">home[‘projects/app’].files                       # =&gt; [‘Rakefile’, ‘readme’]\n\nreadme = home[‘projects/app/readme’]\nreadme.copy_to other_project[‘readme’]\nreadme.move_to home[‘Desktop’]\n\nreadme.write ‘My Cool App’\nreadme.update{|text| text.gsub /App/, ‘App v2’}\nreadme.read                                      # =&gt; “My Cool App v2”\n\napp[‘**/*.rb’]                                   # =&gt; [list of *.rb files]\n\napp[‘**/*.rb’].collect(&amp;:size).reduce(:+)        # =&gt; sources size\n</code></pre>\n\n<p>Same API on any storage type, let’s copy application assets to S3:</p>\n\n<pre><code class=\"ruby\">box = Box.new aws_credentials\napp[‘public’].copy_to box[‘/’]\n</code></pre>\n\n<p>Same API for SFTP, deploying our App:</p>\n\n<pre><code class=\"ruby\">server = Box.new ‘app.com’\napp.copy_to server[‘/apps/app’]\nserver[‘/apps/app’].bash ‘server start’\n</code></pre>\n\n<p>More samples: <a href=\"http://alexeypetrushin.github.com/vfs\">http://alexeypetrushin.github.com/vfs</a></p>\n\n<pre><code class=\"bash\">gem install vfs\n</code></pre>", "original_text" : "[Virtual File System][vfs] provides clean, simple and unified API over different storages (Local File System, AWS S3, SFTP).\n\nI/O operations:\n\n``` ruby\nhome['projects/app'].files                       # => ['Rakefile', 'readme']\n\nreadme = home['projects/app/readme']\nreadme.copy_to other_project['readme']\nreadme.move_to home['Desktop']\n\nreadme.write 'My Cool App'\nreadme.update{|text| text.gsub /App/, 'App v2'}\nreadme.read                                      # => \"My Cool App v2\"\n\napp['**/*.rb']                                   # => [list of *.rb files]\n\napp['**/*.rb'].collect(&:size).reduce(:+)        # => sources size\n```\n\nSame API on any storage type, let's copy application assets to S3:\n\n``` ruby\nbox = Box.new aws_credentials\napp['public'].copy_to box['/']\n```\n\nSame API for SFTP, deploying our App:\n\n``` ruby\nserver = Box.new 'app.com'\napp.copy_to server['/apps/app']\nserver['/apps/app'].bash 'server start'\n```\n\nMore samples: http://alexeypetrushin.github.com/vfs\n\n``` bash\ngem install vfs\n```\n\n[vfs]: http://alexeypetrushin.github.com/vfs", "owner_name" : "admin", "viewers" : [ "manager", "user", "user:admin" ], "collaborators" : [], "updated_at" : { "$date" : 1316726038972 }, "teaser" : " Virtual File System provides clean, simple and unified API over different storages (Local File System, AWS S3, SFTP). I/O operations: home[‘projects/app’].files # =&gt; [‘Rakefile’, ‘readme’] readme = home[‘projects/app/readme’] readme.copy_to other_project[‘readme’] readme.move_to home[‘Desktop’] readme.write ‘My Cool App’ readme.update{|text| ...", "created_at" : { "$date" : 1316724635429 }, "_class" : "Models::Note" }
{ "_id" : { "$oid" : "4e7b9fd67a9d4e31fc000005" }, "tags" : [ "MongoDB", "Project", "_class:Models::Note" ], "slug" : "object-model-for-mongodb", "attachments" : [], "name" : "Object Model for MongoDB", "text" : "<p><a href=\"http://alexeypetrushin.github.com/mongodb_model\">Object Model</a> for MongoDB.</p>\n\n<p>Features:</p>\n\n<ul><li>Models are (almost) pure Ruby Objects.</li>\n<li>Same API for <a href=\"http://alexeypetrushin.github.com/mongodb\">Driver</a> and <a href=\"http://alexeypetrushin.github.com/mongodb_model\">Object Model</a>.</li>\n<li>Minimum extra abstractions, trying to keep things as close to the MongoDB semantic as possible.</li>\n<li>Schema-less, dynamic (with ability to specify types for mass-assignment).</li>\n<li>Models can be saved to any collection, dynamically.</li>\n<li>Full support for composite / embedded objects (with validations, callbacks, …).</li>\n<li>Scopes, default scopes.</li>\n<li>Doesn’t try to mimic ActiveRecord, MongoDB is differrent and the Object Model designed to get most of it.</li>\n<li>Works with multiple connections and databases.</li>\n<li>Support for associations.</li>\n<li>Small codebase, see <a href=\"http://alexeypetrushin.github.com/mongodb_model/code_stats.html\">code stats</a>.</li>\n</ul><p>This tool <strong>exposes simplicity and power of MongoDB and leverages its differences</strong>.</p>\n\n<p>Install MongoDB Model with Rubygems:</p>\n\n<pre><code class=\"bash\">gem install mongodb_model\n</code></pre>\n\n<p>For Rails integration use:</p>\n\n<pre><code class=\"ruby\">require ‘mongo/model/integration/rails’\n</code></pre>\n\n<p>Code sample:</p>\n\n<pre><code class=\"ruby\"># In this example we’ll create simple model and examine basic CRUD and\n# querying operations.\nrequire ‘mongo/model’\n\n# Connecting to test database and cleaning it before starting.\nMongo::Model.default_database_name = :default_test\nMongo::Model.default_database.clear\n\n# Let’s define Game Unit.\n# Models are just plain Ruby Objects, there’s no any Attribute Scheme,\n# Types, Proxies, or other complex stuff, just use standard Ruby practices.\nclass Unit\n  # Inheriting our Unit Class from Mongo::Model (the inherit keyword is\n  # just a simple shortcut including Module and its ClassMethods).\n  inherit Mongo::Model\n\n  # You can specify collection name explicitly or omit it and it will be\n  # guessed from the class name.\n  collection :units\n\n  # There’s no need to define attributes, just use plain old Ruby technics to\n  # of working with objects.\n  attr_accessor :name, :status, :stats\n\n  def inspect; name end\nend\n\n# Stats conaining statistics about Unit (it will be embedded into the\n# Unit).\n#\n# There are no difference between main and embedded objects, all of them\n# are just standard Ruby objects.\nclass Unit::Stats\n  inherit Mongo::Model\n\n  attr_accessor :attack, :life, :shield\nend\n\n# Let’s create two great Heroes.\nzeratul  = Unit.new name: ‘Zeratul’,  status: ‘alive’\nzeratul.stats =  Unit::Stats.new attack: 85, life: 300, shield: 100\n\ntassadar = Unit.new name: ‘Tassadar’, status: ‘dead’\ntassadar.stats = Unit::Stats.new attack: 0,  life: 80,  shield: 300\n\n# Saving units to database\np zeratul.save                                    # =&gt; true\np tassadar.save                                   # =&gt; true\n\n# We made error – mistakenly set Tassadar’s attack as zero, let’s fix it.\ntassadar.stats.attack = 20\np tassadar.save                                   # =&gt; true\n\n# Querying, use standard MongoDB query.\np Unit.first(name: ‘Zeratul’)                     # =&gt; Zeratul\np Unit.all(name: ‘Zeratul’)                       # =&gt; [Zeratul]\nUnit.all name: ‘Zeratul’ do |unit|\n  p unit                                          # =&gt; Zeratul\nend\n\n# Simple dynamic finders (bang versions also availiable).\np Unit.by_name(‘Zeratul’)                         # =&gt; Zeratul\np Unit.first_by_name(‘Zeratul’)                   # =&gt; Zeratul\np Unit.all_by_name(‘Zeratul’)                     # =&gt; [Zeratul]\n</code></pre>", "original_text" : "[Object Model][mongodb_model] for MongoDB.\n\nFeatures:\n\n- Models are (almost) pure Ruby Objects.\n- Same API for [Driver][driver] and [Object Model][mongodb_model].\n- Minimum extra abstractions, trying to keep things as close to the MongoDB semantic as possible.\n- Schema-less, dynamic (with ability to specify types for mass-assignment).\n- Models can be saved to any collection, dynamically.\n- Full support for composite / embedded objects (with validations, callbacks, ...).\n- Scopes, default scopes.\n- Doesn't try to mimic ActiveRecord, MongoDB is differrent and the Object Model designed to get most of it.\n- Works with multiple connections and databases.\n- Support for associations.\n- Small codebase, see [code stats][code_stats].\n\nThis tool **exposes simplicity and power of MongoDB and leverages its differences**.\n\nInstall MongoDB Model with Rubygems:\n\n``` bash\ngem install mongodb_model\n```\n\nFor Rails integration use:\n\n``` ruby\nrequire 'mongo/model/integration/rails'\n```\n\nCode sample:\n\n``` ruby\n# In this example we'll create simple model and examine basic CRUD and\n# querying operations.\nrequire 'mongo/model'\n\n# Connecting to test database and cleaning it before starting.\nMongo::Model.default_database_name = :default_test\nMongo::Model.default_database.clear\n\n# Let's define Game Unit.\n# Models are just plain Ruby Objects, there's no any Attribute Scheme,\n# Types, Proxies, or other complex stuff, just use standard Ruby practices.\nclass Unit\n  # Inheriting our Unit Class from Mongo::Model (the `inherit` keyword is\n  # just a simple shortcut including Module and its ClassMethods).\n  inherit Mongo::Model\n\n  # You can specify collection name explicitly or omit it and it will be\n  # guessed from the class name.\n  collection :units\n\n  # There's no need to define attributes, just use plain old Ruby technics to\n  # of working with objects.\n  attr_accessor :name, :status, :stats\n\n  def inspect; name end\nend\n\n# Stats conaining statistics about Unit (it will be embedded into the\n# Unit).\n#\n# There are no difference between main and embedded objects, all of them\n# are just standard Ruby objects.\nclass Unit::Stats\n  inherit Mongo::Model\n\n  attr_accessor :attack, :life, :shield\nend\n\n# Let's create two great Heroes.\nzeratul  = Unit.new name: 'Zeratul',  status: 'alive'\nzeratul.stats =  Unit::Stats.new attack: 85, life: 300, shield: 100\n\ntassadar = Unit.new name: 'Tassadar', status: 'dead'\ntassadar.stats = Unit::Stats.new attack: 0,  life: 80,  shield: 300\n\n# Saving units to database\np zeratul.save                                    # => true\np tassadar.save                                   # => true\n\n# We made error - mistakenly set Tassadar's attack as zero, let's fix it.\ntassadar.stats.attack = 20\np tassadar.save                                   # => true\n\n# Querying, use standard MongoDB query.\np Unit.first(name: 'Zeratul')                     # => Zeratul\np Unit.all(name: 'Zeratul')                       # => [Zeratul]\nUnit.all name: 'Zeratul' do |unit|\n  p unit                                          # => Zeratul\nend\n\n# Simple dynamic finders (bang versions also availiable).\np Unit.by_name('Zeratul')                         # => Zeratul\np Unit.first_by_name('Zeratul')                   # => Zeratul\np Unit.all_by_name('Zeratul')                     # => [Zeratul]\n```\n\n[driver]:       http://alexeypetrushin.github.com/mongodb\n[code_stats]:   http://alexeypetrushin.github.com/mongodb_model/code_stats.html\n[mongodb_model]: http://alexeypetrushin.github.com/mongodb_model", "owner_name" : "admin", "viewers" : [ "manager", "user", "user:admin" ], "collaborators" : [], "updated_at" : { "$date" : 1316726028310 }, "teaser" : " Object Model for MongoDB. Features: Models are (almost) pure Ruby Objects. Same API for Driver and Object Model. Minimum extra abstractions, trying to keep things as close to the MongoDB semantic as possible. Schema-less, dynamic (with ability to specify types for mass-assignment). Models can be saved to any collection, dynamically. Full support ...", "created_at" : { "$date" : 1316724694844 }, "_class" : "Models::Note" }
